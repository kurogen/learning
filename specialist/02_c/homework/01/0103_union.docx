Union (Смесь) - это средство, позволяющее хранить в отдельные моменты времени данные различных типов в одном и том же месте памяти. Смеси дают возможность работать в одной и той же области памяти с данными различного вида, не внося в программу какую-либо информацию, зависящую от машины. В некоторых литературных источниках можно встретить другое название смеси - объединение.
Смеси описываются таким же образом, как и структуры, но вместо ключевого слова struct используется ключевое слово union. Вы можете, как и для структур, определить шаблон смеси с именем типа и в этом же операторе одну или несколько переменных смеси либо описание переменных может быть отделено от определения шаблона. Вот пример шаблона смеси с именем типа ELEMENTS:
union ELEMENTS {
int number;
float real;
char symbol;
char *pointer;
};
Теперь описываем данные типа смесь:
union ELEMENTS dat, mas[5], *pu;
В этом примере определяется переменная смеси dat, массив переменных смеси mas, и указатель на смесь - pu. При объявлении объекта программы типа смесь компилятор выделяет объем памяти достаточный для хранения максимального по размеру элемента смеси. В приведенном примере переменная dat будет занимать 4 байта. Этого достаточно для размещения элемента типа float и любого из всех остальных элементов смеси.
Для получения доступа к элементу смеси, как и для структур, используется операция . (точка). Так как смесь хранит значение только одного из элементов, операция получения элемента показывает какой тип данных используется.
Например:
dat.number=57;
dat.real=3.5;
mas[2].symbol='A';
Программист должен сам следить за типом данных, записываемых в данный
момент в смесь. Для переменных типа смесь можно использовать операции взятия
адреса и получения элемента через указатель:
pu=&dat;
x=pu->number;
В заключение приведем пример программы, иллюстрирующей возможности
использования смеси для печати двоичных ASCII-кодов символов, вводимых с
клавитуры. Программа печатает символ и его двоичный код до тех пор, пока не
будет введен символ $ (знак денежной единицы).
/* Программа выдачи двоичного кода введенного символа */
/* Для завершения работы программы ввести символ $ */
#include <stdio.h>
main(){
struct BYTE {
unsigned a: 1;
unsigned b: 1;
unsigned c: 1;
unsigned d: 1;
unsigned e: 1;
unsigned f: 1;
unsigned g: 1;
unsigned h: 1;
};
union SYMB {
unsigned char ch;
struct BYTE bit;
}symbol;
do {
symbol.ch=getche(); /* Функция getche читаетсимвол */
printf(":"); /* и отображает его на экране */
if (symbol.bit.h) printf("1");else printf("0");
if (symbol.bit.g) printf("1"); else printf("0");
if (symbol.bit.f) printf("1"); else printf("0");
if (symbol.bit.e) printf("1"); else printf("0");
if (symbol.bit.d) printf("1"); else printf("0");
if (symbol.bit.c) printf("1"); else printf("0");
if (symbol.bit.b) printf("1"); else printf("0");
if (symbol.bit.a) printf("1"); else printf("0");
printf("\n");
}
while (symbol.ch!='$');
}
/* Конец программы */
Результат выполнения программы:
g:01100111
2:00110010
=:00111101
л:11011011
f:01100110
Ж:10110110
\:01011100
б:11010001
!:00100001
к:11011010
$:00100100
Рассмотренная программа использует переменную типа смесь - symbol, которая с одной стороны может представлять собой данное типа char, а с другой, - данное типа битовое поле. Именно эта особенность позволяет достаточно просто реализовать программу печати кодов вводимых символов. Обратите внимание на то, что проверка значений битовых полей производится в порядке обратном тому, который дан в описании битовых полей шаблона BYTE. Это обусловлено особенностью формирования битовых полей в направлении от младших битов к старшим. Включение в смесь битовых полей единичного размера, количество которых соответствует числу бит максимального по длине данного смеси, позволяет получить доступ не только к данному в целом, находящемуся в смеси, но к каждому его биту в отдельности.

